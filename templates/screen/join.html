<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∏–≥—Ä–µ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
      margin: 0;
      padding: 1rem;
      background: linear-gradient(180deg, #eaf3ff 0%, #f9fbff 100%);
      color: #222;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }

    .container {
      max-width: 460px;
      margin-top: 1rem;
      background: #fff;
      border-radius: 18px;
      box-shadow: 0 8px 20px rgba(15, 23, 42, 0.08);
      padding: 1.2rem 1rem;
      text-align: center;
      overflow: hidden;
    }

    h1 {
      font-size: 1.6rem;
      margin-bottom: 0.4rem;
      color: #2563eb;
    }

    p {
      margin-bottom: 0.6rem;
      line-height: 1.4;
    }

    #status {
      font-size: 0.9rem;
      color: #64748b;
      margin-bottom: 0.5rem;
    }

    .auto-start {
      margin: 0.9rem 0;
      padding: 0.85rem 1rem;
      border-radius: 14px;
      background: rgba(37, 99, 235, 0.12);
      color: #1d4ed8;
      display: flex;
      justify-content: center;
      align-items: center;
      box-shadow: inset 0 0 0 1px rgba(37, 99, 235, 0.08);
    }

    .auto-start__status {
      margin: 0;
      font-weight: 600;
      display: inline-flex;
      gap: 0.45rem;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      text-align: center;
      color: inherit;
    }

    .auto-start__status .question-timer {
      margin: 0;
      background: rgba(37, 99, 235, 0.2);
      color: inherit;
    }

    #question {
      overflow: hidden;
      margin-top: 0.6rem;
    }

    .question-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.35rem;
      flex-wrap: wrap;
    }

    .question-timer {
      margin: 0;
      padding: 0.25rem 0.65rem;
      border-radius: 999px;
      background: rgba(37, 99, 235, 0.12);
      color: #1d4ed8;
      font-weight: 700;
      font-variant-numeric: tabular-nums;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      transition: background 0.2s ease, color 0.2s ease;
    }

    .question-timer.is-warning {
      background: rgba(248, 113, 113, 0.16);
      color: #dc2626;
    }

    .question-inner {
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }

    /* üéû –ê–Ω–∏–º–∞—Ü–∏—è */
    @keyframes slideIn {
      0% {
        opacity: 0;
        transform: translateY(-220px) scale(0.96);
      }
      70% {
        opacity: 1;
        transform: translateY(10px) scale(1.02);
      }
      85% {
        transform: translateY(-5px) scale(1);
      }
      100% {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes slideOut {
      0% {
        opacity: 1;
        transform: translateY(0);
      }
      40% {
        opacity: 0.9;
        transform: translateY(40px);
      }
      100% {
        opacity: 0;
        transform: translateY(240px);
      }
    }

    .question-inner.slide-in {
      animation: slideIn 1s cubic-bezier(0.23, 1, 0.32, 1.05) forwards;
    }

    .question-inner.slide-out {
      animation: slideOut 0.9s cubic-bezier(0.65, 0, 0.35, 1) forwards;
    }

    /* –ö–Ω–æ–ø–∫–∏ */
    #options {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 0.5rem;
    }

    .final-screen__scoreboard {
      list-style: none;
      margin: 1rem 0 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

   .final-screen__meta {
  display: inline-flex;
  flex-wrap: nowrap;
  gap: 0.4rem;
  align-items: center;
  justify-content: flex-end;
  font-size: 0.95rem;
  color: #475569;
  white-space: nowrap;
  margin-left: 0.5rem;
}


    .final-screen__scoreboard li.is-record {
      background: rgba(59, 130, 246, 0.14);
      box-shadow: 0 10px 22px rgba(59, 130, 246, 0.22);
    }

    .final-screen__position {
      font-size: 1.4rem;
      font-weight: 700;
      color: #4338ca;
      min-width: 3.2ch;
      text-align: left;
    }

    .final-screen__name {
      text-align: left;
      word-break: break-word;
    }

    .final-screen__meta {
  display: inline-flex;
  flex-wrap: nowrap;
  gap: 0.4rem;
  align-items: center;
  justify-content: flex-end;
  font-size: 0.95rem;
  color: #475569;
  white-space: nowrap;
}


    .final-screen__separator {
      opacity: 0.6;
      margin: 0 0.25rem;
    }

    .final-screen__time,
    .final-screen__points {
      font-variant-numeric: tabular-nums;
    }

    @media (max-width: 520px) {
      .final-screen__row {
        font-size: 1rem;
        padding: 0.75rem 0.9rem;
      }

      .final-screen__position {
        font-size: 1.3rem;
      }

      .final-screen__meta {
        font-size: 0.9rem;
      }
    }

    .btn {
      display: block;
      width: 100%;
      padding: 18px 14px;
      font-size: 1.15rem;
      font-weight: 600;
      border: none;
      border-radius: 12px;
      background: linear-gradient(135deg, #4a90e2, #6cc1ff);
      color: white;
      cursor: pointer;
      box-shadow: 0 3px 12px rgba(0, 0, 0, 0.12);
      transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.3s;
    }

    .btn:hover {
      transform: scale(1.03);
      box-shadow: 0 4px 14px rgba(0, 0, 0, 0.18);
      background: linear-gradient(135deg, #5aa8ff, #84d1ff);
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .btn.selected {
      background: linear-gradient(135deg, #22c55e, #4ade80);
      box-shadow: 0 3px 10px rgba(34, 197, 94, 0.3);
      color: white;
    }

    @media (max-width: 600px) {
      .container {
        margin-top: 0.5rem;
        padding: 1rem;
      }
      h1 {
        font-size: 1.4rem;
      }
      .auto-start {
        padding: 0.75rem 0.85rem;
      }
      .auto-start__status {
        font-size: 0.95rem;
      }
      .btn {
        padding: 16px 12px;
        font-size: 1.05rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>–í—ã –≤ –∏–≥—Ä–µ!</h1>
    <p>–ò–≥—Ä–æ–∫ <strong>{{ player_name }}</strong> –ø–æ–¥–∫–ª—é—á–∏–ª—Å—è –∫ –∫–æ–º–Ω–∞—Ç–µ <strong>{{ room_id }}</strong>.</p>
    {% if quiz_title %}
    <p>–¢–µ–∫—É—â–∞—è –≤–∏–∫—Ç–æ—Ä–∏–Ω–∞: <strong>{{ quiz_title }}</strong></p>
    {% endif %}
    <p id="status">–û–∂–∏–¥–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏–π –æ—Ç –≤–µ–¥—É—â–µ–≥–æ‚Ä¶</p>

    <div id="auto-start" class="auto-start" hidden aria-hidden="true">
      <p id="auto-start-status" class="auto-start__status" aria-live="polite" role="status">
        –ò–≥—Ä–∞ –Ω–∞—á–Ω—ë—Ç—Å—è —á–µ—Ä–µ–∑
        <span id="auto-start-countdown" class="question-timer" aria-live="off">00:00</span>
        (–∞–≤—Ç–æ—Å—Ç–∞—Ä—Ç)
      </p>
    </div>

    <section id="question" hidden>
      <div id="question-inner" class="question-inner">
        <div class="question-meta">
          <p id="question-progress"></p>
          <p id="question-timer" class="question-timer" hidden>00:00</p>
        </div>
        <h2 id="question-title"></h2>
        <div id="options"></div>
      </div>
    </section>

    <section id="result" hidden>
      <h3>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã</h3>
      <p id="answer-summary"></p>
      <ul id="scoreboard" class="final-screen__scoreboard"></ul>
    </section>
  </div>

  <script src="{{ url_for('static', path='js/leaderboard.js') }}"></script>
  <script>
    const roomId = "{{ room_id }}";
    const playerName = "{{ player_name }}";
    const protocol = window.location.protocol === "https:" ? "wss" : "ws";
    const wsUrl = `${protocol}://${window.location.host}/screen/ws/player/${roomId}`;
    const socket = new WebSocket(wsUrl);

    const statusEl = document.getElementById('status');
    const questionSection = document.getElementById('question');
    const questionInner = document.getElementById('question-inner');
    const questionProgress = document.getElementById('question-progress');
    const questionTimer = document.getElementById('question-timer');
    const questionTitle = document.getElementById('question-title');
    const optionsContainer = document.getElementById('options');
    const resultSection = document.getElementById('result');
    const answerSummary = document.getElementById('answer-summary');
    const scoreboardList = document.getElementById('scoreboard');
    const autoStartContainer = document.getElementById('auto-start');
    const autoStartCountdown = document.getElementById('auto-start-countdown');
    const initialAutoStartData = {{ auto_start | tojson | safe }};

    const initialStatusText = statusEl?.textContent || '–û–∂–∏–¥–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏–π –æ—Ç –≤–µ–¥—É—â–µ–≥–æ‚Ä¶';

    let hasAnswered = false;
    let currentQuestion = null;
    let serverTimeOffset = 0;

    const syncServerTime = (isoString) => {
      if (!isoString) return;
      const serverTimestamp = Date.parse(isoString);
      if (Number.isNaN(serverTimestamp)) return;
      serverTimeOffset = serverTimestamp - Date.now();
    };

    const getServerNow = () => Date.now() + serverTimeOffset;

    const formatTimerValue = (totalSeconds) => {
      const minutes = String(Math.floor(totalSeconds / 60)).padStart(2, '0');
      const seconds = String(totalSeconds % 60).padStart(2, '0');
      return `${minutes}:${seconds}`;
    };

    const createTimerController = (
      element,
      {
        defaultText = '00:00',
        warningThreshold = 10,
        autoHide = false,
        onTick,
        onClear,
        onComplete,
      } = {}
    ) => {
      let target = element ?? null;
      let intervalId = null;
      let endTime = 0;

      const setHidden = (hidden) => {
        if (!target || !autoHide) return;
        if (hidden) {
          target.hidden = true;
          target.setAttribute('hidden', '');
          target.setAttribute('aria-hidden', 'true');
        } else {
          target.hidden = false;
          target.removeAttribute('hidden');
          target.setAttribute('aria-hidden', 'false');
        }
      };

      const cancelInterval = () => {
        if (intervalId !== null) {
          window.clearInterval(intervalId);
          intervalId = null;
        }
      };

      const render = () => {
        if (!target || !endTime) {
          cancelInterval();
          return;
        }
        const remaining = endTime - getServerNow();
        const totalSeconds = Math.max(0, Math.ceil(remaining / 1000));
        const formatted = formatTimerValue(totalSeconds);

        if (typeof onTick === 'function') onTick(formatted, totalSeconds);
        if (target) target.textContent = formatted;

        if (target) {
          if (totalSeconds <= warningThreshold) target.classList.add('is-warning');
          else target.classList.remove('is-warning');
        }

        if (remaining <= 0) {
          controller.clear();
          if (typeof onComplete === 'function') onComplete();
        }
      };

      const controller = {
        start(startIso, durationSeconds) {
          if (!target) return;
          const start = Date.parse(startIso);
          const duration = Number(durationSeconds);
          if (Number.isNaN(start) || !duration || duration <= 0) {
            this.clear();
            return;
          }
          endTime = start + duration * 1000;
          setHidden(false);
          target.classList.remove('is-warning');
          cancelInterval();
          render();
          intervalId = window.setInterval(render, 250);
        },
        clear() {
          cancelInterval();
          endTime = 0;
          if (target) {
            target.textContent = defaultText;
            target.classList.remove('is-warning');
          }
          if (typeof onClear === 'function') onClear();
          setHidden(true);
        },
      };

      return controller;
    };

    const questionTimerController = createTimerController(questionTimer, {
      autoHide: true,
    });

    const autoStartTimer = createTimerController(autoStartCountdown, {
      autoHide: false,
      onTick: (formatted) => {
        if (statusEl) {
          statusEl.textContent = `–ò–≥—Ä–∞ –Ω–∞—á–Ω—ë—Ç—Å—è —á–µ—Ä–µ–∑ ${formatted} (–∞–≤—Ç–æ—Å—Ç–∞—Ä—Ç)`;
        }
      },
      onComplete: () => {
        hideAutoStartCountdown({ resetStatus: false });
        if (statusEl) {
          statusEl.textContent = '–ò–≥—Ä–∞ –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏‚Ä¶';
        }
      },
    });

    const showAutoStartContainer = () => {
      if (!autoStartContainer) return;
      autoStartContainer.hidden = false;
      autoStartContainer.removeAttribute('hidden');
      autoStartContainer.setAttribute('aria-hidden', 'false');
    };

    const hideAutoStartCountdown = ({ resetStatus = true } = {}) => {
      autoStartTimer.clear();
      if (autoStartContainer) {
        autoStartContainer.hidden = true;
        autoStartContainer.setAttribute('hidden', '');
        autoStartContainer.setAttribute('aria-hidden', 'true');
      }
      if (resetStatus && statusEl) {
        statusEl.textContent = initialStatusText;
      }
      if (autoStartCountdown) {
        autoStartCountdown.classList.remove('is-warning');
      }
    };

    const handleAutoStartScheduled = (payload) => {
      if (!payload) return;
      const serverTime = payload.server_time;
      const scheduledAt = typeof payload.scheduled_at === 'string' ? payload.scheduled_at : null;
      if (serverTime) syncServerTime(serverTime);
      else if (scheduledAt) syncServerTime(scheduledAt);

      if (autoStartCountdown) {
        autoStartCountdown.classList.remove('is-warning');
      }

      const parsedDelay = Number(payload.delay);
      let durationSeconds =
        Number.isFinite(parsedDelay) && parsedDelay >= 0 ? Number(parsedDelay) : null;
      let startIso = null;

      if (scheduledAt) {
        const scheduledTimestamp = Date.parse(scheduledAt);
        if (!Number.isNaN(scheduledTimestamp)) {
          if (durationSeconds === null) {
            const remainingMs = scheduledTimestamp - getServerNow();
            durationSeconds = Math.max(0, remainingMs / 1000);
          }
          if (durationSeconds !== null) {
            const startTimestamp = scheduledTimestamp - durationSeconds * 1000;
            startIso = new Date(startTimestamp).toISOString();
          }
        }
      }

      if (!startIso && durationSeconds !== null) {
        startIso = new Date(getServerNow()).toISOString();
      }

      if (durationSeconds !== null && durationSeconds <= 0.5) {
        showAutoStartContainer();
        autoStartTimer.clear();
        if (autoStartCountdown) {
          autoStartCountdown.textContent = '00:00';
          autoStartCountdown.classList.add('is-warning');
        }
        if (statusEl) {
          statusEl.textContent = '–ò–≥—Ä–∞ –Ω–∞—á–Ω—ë—Ç—Å—è —á–µ—Ä–µ–∑ 00:00 (–∞–≤—Ç–æ—Å—Ç–∞—Ä—Ç)';
        }
        return;
      }

      if (!startIso || durationSeconds === null) {
        hideAutoStartCountdown();
        return;
      }

      showAutoStartContainer();
      autoStartTimer.start(startIso, durationSeconds);
    };

    const handleAutoStartCancelled = (payload) => {
      if (payload?.server_time) syncServerTime(payload.server_time);
      hideAutoStartCountdown({ resetStatus: false });
      if (statusEl) {
        statusEl.textContent = '–ê–≤—Ç–æ–∑–∞–ø—É—Å–∫ –æ—Ç–º–µ–Ω—ë–Ω. –û–∂–∏–¥–∞–µ–º –≤–µ–¥—É—â–µ–≥–æ.';
      }
    };

    const handleAutoStartTriggered = (payload) => {
      if (payload?.server_time) syncServerTime(payload.server_time);
      hideAutoStartCountdown({ resetStatus: false });
      if (statusEl) {
        statusEl.textContent = '–ò–≥—Ä–∞ –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏‚Ä¶';
      }
    };

    questionInner.addEventListener('animationend', (event) => {
      if (event.animationName === 'slideIn') {
        questionInner.classList.remove('slide-in');
      }
    });

    socket.addEventListener('open', () => {
      socket.send(JSON.stringify({ action: 'join', player: playerName }));
      statusEl.textContent = '–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ. –û–∂–∏–¥–∞–µ–º –≤–æ–ø—Ä–æ—Å‚Ä¶';
    });

    socket.addEventListener('message', (event) => {
      const data = JSON.parse(event.data);
      const { event: eventName, payload } = data;

      switch (eventName) {
        case 'player_joined':
          statusEl.textContent = `–í –∫–æ–º–Ω–∞—Ç–µ ${payload.players.length} –∏–≥—Ä–æ–∫(–æ–≤).`;
          break;
        case 'show_question':
          renderQuestion(payload);
          break;
        case 'show_results':
          renderResults(payload);
          break;
        case 'show_final':
          renderFinal(payload);
          break;
        case 'auto_start_scheduled':
          handleAutoStartScheduled(payload);
          break;
        case 'auto_start_cancelled':
          handleAutoStartCancelled(payload);
          break;
        case 'auto_start_triggered':
          handleAutoStartTriggered(payload);
          break;
      }
    });

    if (initialAutoStartData) {
      handleAutoStartScheduled(initialAutoStartData);
    } else {
      hideAutoStartCountdown();
    }

    const renderQuestion = (payload) => {
      if (!payload) return;

      const startedAt = payload.question_started_at;
      const duration = payload.question_duration;
      const serverTime = payload.server_time;
      if (serverTime) syncServerTime(serverTime);
      else if (startedAt) syncServerTime(startedAt);

      hideAutoStartCountdown({ resetStatus: false });

      if (!payload.question) {
        questionTimerController.clear();
        if (statusEl) {
          statusEl.textContent = initialStatusText;
        }
        return;
      }

      const { question_number: number, total_questions: total, question: questionData } = payload;

      const applyContent = () => {
        currentQuestion = questionData;
        hasAnswered = false;
        resultSection.hidden = true;

        questionProgress.textContent = `–í–æ–ø—Ä–æ—Å ${number} –∏–∑ ${total}`;
        questionTitle.textContent = questionData.title || questionData.text || '–í–æ–ø—Ä–æ—Å';

        optionsContainer.innerHTML = '';
        (questionData.options || []).forEach((option) => {
          const button = document.createElement('button');
          button.type = 'button';
          button.textContent = `${option.id}. ${option.text}`;
          button.classList.add('btn');
          button.addEventListener('click', () => sendAnswer(option.id, button));
          optionsContainer.appendChild(button);
        });

        statusEl.textContent = '–í—ã–±–µ—Ä–∏—Ç–µ –æ—Ç–≤–µ—Ç.';

        if (startedAt && duration) {
          questionTimerController.start(startedAt, duration);
        } else {
          questionTimerController.clear();
        }
      };

      const startSlideIn = () => {
        questionSection.hidden = false;
        void questionInner.offsetWidth;
        questionInner.classList.remove('slide-out');
        questionInner.classList.add('slide-in');
      };

      if (questionSection.hidden) {
        applyContent();
        startSlideIn();
        return;
      }

      questionInner.classList.remove('slide-in');
      questionInner.classList.add('slide-out');

      const handleAnimationEnd = (event) => {
        if (event.animationName !== 'slideOut') return;
        questionInner.removeEventListener('animationend', handleAnimationEnd);
        applyContent();
        startSlideIn();
      };

      questionInner.addEventListener('animationend', handleAnimationEnd);
    };

    const sendAnswer = (answerId, button) => {
      if (hasAnswered || socket.readyState !== WebSocket.OPEN) return;
      socket.send(JSON.stringify({ action: 'answer', answer: answerId }));
      hasAnswered = true;
      disableOptions(button);
      statusEl.textContent = '–û—Ç–≤–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω. –û–∂–∏–¥–∞–µ–º –¥—Ä—É–≥–∏—Ö –∏–≥—Ä–æ–∫–æ–≤‚Ä¶';
    };

    const disableOptions = (selectedButton) => {
      const buttons = optionsContainer.querySelectorAll('button');
      buttons.forEach((btn) => {
        btn.disabled = true;
        if (btn === selectedButton) btn.classList.add('selected');
      });
    };

    const renderResults = (payload) => {
      if (!payload) return;
      if (payload.server_time) syncServerTime(payload.server_time);
      questionTimerController.clear();
      hideAutoStartCountdown({ resetStatus: false });
      questionSection.hidden = true;
      resultSection.hidden = false;

      const result = (payload.results || []).find((r) => r.player === playerName);
      if (result?.is_correct)
        answerSummary.textContent = `–í–µ—Ä–Ω–æ! –í–∞—à —Å—á—ë—Ç: ${result.score}.`;
      else answerSummary.textContent = `–ù–µ–≤–µ—Ä–Ω–æ. –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç: ${payload.correct_answer}.`;

      renderScoreboard(payload.scoreboard || []);
    };

    const renderFinal = (payload) => {
      if (payload?.server_time) syncServerTime(payload.server_time);
      questionTimerController.clear();
      hideAutoStartCountdown({ resetStatus: false });
      questionSection.hidden = true;
      resultSection.hidden = false;
      answerSummary.textContent = '–ò–≥—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞! –ò—Ç–æ–≥–æ–≤—ã–π —Å—á—ë—Ç:';
      renderScoreboard(payload.scoreboard || []);
    };

    const renderScoreboard = (data) => {
      if (window.Leaderboard) {
        window.Leaderboard.render(scoreboardList, data);
      } else {
        scoreboardList.innerHTML = '';
      }
    };
  </script>
</body>
</html>